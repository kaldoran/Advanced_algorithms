\documentclass[10pt,a4paper]{report}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{color}
\usepackage{enumitem}
\usepackage[top=1cm, bottom=2cm, left=2cm, right=2cm]{geometry}

\usepackage{fancyhdr}
\pagestyle{fancy}

\fancyhead{}
\fancyfoot{} 
\lhead{ \hspace{0.1cm} Promo 2014-2015  \hspace{0.4cm} \vline}
\chead{Advanced Algorithm}
\rhead{K.B - K.L - N.R}
\rfoot{\thepage}

\author{Kevin BASCOL, Kevin LAOUSSING, Nicolas REYNAUD}
\title{Algorithme avancé : \\Problème du voyageur de commerce}

\makeatletter
\renewcommand{\thesection}{\@arabic\c@section}
\makeatother

\begin{document}

\makeatletter
	\begin{titlepage}
	
	\centering
		{
		\vspace*{5cm}
		\hrule height 2pt
		\vspace{0.7cm}
		\Huge \textbf{\@title}}\\
		\vspace{0.7cm}
		\hrule height 2pt
		
		\vfill
		\vspace{1cm}
		\@author\\
		\end{titlepage}
\makeatother
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{3}
\renewcommand{\contentsname}{Sommaire}
\begingroup\makeatletter
\def\@makeschapterhead#1{%
  {\parindent \z@ \raggedright
    \normalfont
    \interlinepenalty\@M
    \Huge \bfseries  #1\par\nobreak
    \vskip 20pt% <---- à réduire pour avoir plus de place
  }}\makeatother
\tableofcontents
\endgroup
\thispagestyle{empty}
\setcounter{page}{0}
\newpage

\newgeometry{top=2cm, bottom=2cm, left=2cm, right=2cm}

\section{Introduction}
\begin{flushleft}
Le problème du voyageur de commerce, consiste en la recherche d'un trajet minimal permettant à un voyageur de visiter n villes. En règle générale on cherche à minimiser le temps de parcours total ou la distance totale parcourue.\\
Il existe plusieurs approche pour résoudre ce problème, parmi lesquelles on peut distinguer les approches donnant des résultats exactes et les approches donnant des résultats approximatives.
L'objectif de notre projet est d'implémenter ces différentes approches, de pouvoir les tester, de pouvoir analyser les résultats et de déterminer quel est le meilleur compromis entre temps de résolutions et "exactitude" de la solution.
\end{flushleft}


\section{Organisation du projet}

	\subsection{Planning}
	
		\subsubsection{Diagramme de gantt}
		
			\includegraphics[scale=0.37]{./Ressource/planning_AA.png}
		
	
	\subsection{Langage utilisé et outil de développement}
	\begin{flushleft}
	Nous avons choisi d'implémenter tous nos algorithmes en langage C  pour sa rapidité. En effet les graphes étant garder en mémoire, 
	\end{flushleft}
	
\section{Algorithmes de résolution de problème du voyageur de commerce}

	\subsection{Structure de donnée}
	
	\subsection{Algorithme donnant une solution optimale}
		\subsubsection{Brute force}
		
		\subsubsection{Séparation et évaluation}
		
		\paragraph{Résumé de l'algorithme}
		L'algorithme de séparation et évaluation consiste en un parcours de l'arbre de tous les chemins possible dans le graphe des villes. Mais si le chemin menant à un nœud possède un poids total supérieur à la meilleurs solution trouvée jusque là, alors il ne parcourra pas les sous-arbres de ce nœud.\\
		
		\paragraph{Commentaires sur l'implémentation}
		
		
		
		\subsubsection{Séparation et évaluation avec retrait d'arêtes}		
		
		\paragraph{Résumé de l'algorithme}
		L'algorithme de séparation et évaluation avec retrait d'arêtes consiste en un parcours d'arbre. Celui-ci est un arbre binaire, chaque nœud est la matrice des arêtes du graphe, le fils gauche correspond à la matrice résultante du passage par une arête choisie, le fils droit représente la matrice résultante du retrait de cette arête. Le parcours s'arrête au moment où la fonction d'évaluation retourne une valeur supérieur à celle de la meilleure solution trouvée.\\
		
		\paragraph{Commentaires sur l'implémentation}		
		
		
	\subsection{Algorithme donnant une solution approximative}
	
		\subsubsection{Approche cupide}
		
		\paragraph{Résumé de l'algorithme}
		L'algorithme de l'approche cupide commence par se positionner sur un nœud du graphe. A partir de là, l'algorithme passe au nœud suivant non visité en regardant l'arête avec le poids minimum. Et ainsi de suite jusqu'à avoir parcouru tout les nœuds du graphe.
		
		\subsubsection{Approche aléatoire}
		
		\paragraph{Résumé de l'algorithme}
		L'approche aléatoire est très simple. L'algorithme se place sur un nœud aléatoire du graphe. A partir de là, l'algorithme passe au nœud suivant non visité en choisissant une arête de manière aléatoire. Jusqu'à revenir à sont point de départ.
		L'algorithme est lancé une première fois. Puis est lancé 100 fois en comparant les résultats entre eux. A chaque fois le chemin avec le coup le moins élevé est choisit.
		
		\subsubsection{Approche avec l'arbre couvrant de poids minimal}
		
		\subsubsection{Approche génétique}
		
		\paragraph{Résumé de l'algorithme}
		L'algorithme de l'approche génétique passe par plusieurs sous méthode. \\
		Pour commencer une population N de solution est générée. \\
		Cette population est alors modifiée, elle évolue. \\
		l'évolution consiste à trier la population par ordre croissant, à partir de là, un pourcentage d'élite est gardé. Les élites peuvent, avec un faible pourcentage de chance muter. La mutation se traduit par l'inversion de 2 nœuds dans la solution élite. \\
		Le reste de la population subit alors des croisements et des mutations. Les croisement se font sur deux parents. Les parents sont choisit, soit parmi les élites avec un faible pourcentage de chance. Soit parmi une sélection aléatoire de parent parmi les éléments triées. \\
		Le tournois choisit simplement alors la meilleurs solution (Celle avec le cout le plus faible) parmi la sélection aléatoire. \\
		
		Le croisement peut alors commencer. Le croisement comporte alors 2 étapes :
		\begin{itemize}
			\item On commencer par copier une partie de la solution du parent numéro 1. Cette partie est choisit aléatoirement.
			\item On complète ensuite la solution fils obtenu en complétant celle ci par les nœuds présent dans le second parent. En conservant l'ordre présent dans le parent 2.
		\end{itemize}
		Le fils ainsi obtenu à alors un faible chance de muter. \\
		
		L'évolution est ensuite répétée X fois. En prenant comme nouvelle entré la sortie de l'évolution précédente. \\
		Pour finir l'algorithme choisit la meilleurs solution ( Celle avec le plus faible coût ) après évolution . \\
\newpage
\section{Etudes d'efficacités des algorithmes}

	\subsection{Graphes générés aléatoirement}
		\subsubsection{Tests temps d'exécution}
			\includegraphics[scale=0.45]{./Ressource/temps_graphes_random.png}	
		
		\subsubsection{Tests coût}
			
			\includegraphics[scale=0.40]{./Ressource/cout_graphes_random.png}
			
		\subsubsection{Conclusion}
			
	\subsection{Graphes en ligne}
		\subsubsection{Tests temps d'exécution}
			\includegraphics[scale=0.45]{./Ressource/temps_graphes_site.png}
		
	
	\subsubsection{Tests coût}
			\includegraphics[scale=0.45]{./Ressource/cout_graphes_site.png}
			
	\subsubsection{Conclusion}

\section{Conclusion}
\section{Annexes}

	\subsection{DataConverter}
	
	\subsection{TSPGenerateur}

\end{document}